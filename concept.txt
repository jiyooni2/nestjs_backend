GraphQL
    use graphql in nestJS
    npm i @nestjs/graphql graphql-tools graphql apollo-server-express

    nestjs/graphql : nestjs에서만의 graphql방식, work on top of the apollo-server-express

AppModule
    main.ts로 import되는 유일한 모듈(루트 모듈)
    main.ts에서 NestFactory.create로 애플리케이션 생성

    AppModule에 필요한 모듈을 추가해야함

    forRoot : configure the GraphQLModule
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
    }),

@Resolver
    resolvers.js 에서 작성하던 것들을 적으면 됨
    @Query(return type)
    @Mutation(return type)

    in graphql [temp], in TS temp[]

entity
    DB model과 비슷
    @ObjectType
    @Field(return type,options)

@Args
    query의 Args를 받을 수 있음
    @Args의 type은 graphql과 nest 모두에서 작동함
    
    @Mutation((returns) => Boolean)
    createRestaurant(
        @Args('name') name: string,
        @Args('isVegan') isVegan: boolean,
        @Args('address') address: string,
        @Args('ownerName') ownerName: string,
    ):Boolean {
        return true;
    }

    딱봐도 귀찮아보임, input Type을 만들 수 있음

Input Type
    전체 object를 전달 할 수 있음(dto)

@InputType vs @ArgsType
    InputType : 하나의 obj, arg로써 graphql에 전달, obj를 전달해줌
    ArgsType : 분리된 값들을 graphql arg로 전달해 줄 수 있도록 해줌, args의 이름을 쓰지 않아도 됨


Class Validator to ArgsType
    npm i class-validator
    validation pipeline 안만들면, validation 안됨
    
    dto에 validation을 적용하면, input data에서 먼저 걸러짐

    Class-validator works by setting metadata about fields via the decorators it uses, and can only do so much on type alone.
    The library then reads that metadata and checks it against the current type of the object/field and determines if its conditions are satisfied.
    The library is self contained so it doesn't need to go to a server or anything.
    라우터나 컨트롤러에 도달하기 전에 json body를 class-transformer를 통해서 class객체로 변환한 뒤에,
    class-validator로 검증을 하고 타입이 맞다면 컨트롤러/라우터에 전달(continue), 아니라면 바로 리턴

TypeORM(Object Relational Mapping)
    직접 SQL문 작성해서 DB로 보내는 것도 가능하지만
    TypeORM 사용하면, type을 쓸 수 있고 nest와도 연계 가능, DB상호작용 테스트 가능
    SQL을 쓰는 대신 코드를 사용해서 DB와 통신 가능
    많은 DB를 지원함

    TypeOrmModule
        synchronize
            entities 찾고 자동으로 migration
            DB의 구성을 자동으로 바꿔줌
            update the DB to reflect the typeOrm cols.

pgAdmin은 postgreSQL와 상호작용 하기 윈한 도구 일 뿐,
    postgreSQL server running check

TypeORM
    mongoose, sequelize 등등 있음
    typeORM : TS로 만들어지고 더 친화적
    npm install --save @nestjs/typeorm typeorm pg

.env in nestJS
    @nestjs/config
    
    runs on top of the dotenv 
    하지만 nestJS방식으로 동작


package.json에서 실행시에 NODE_ENV를 환경변수로 넘겨줄 수 있음
    use cross-env

use joi in validationSchema
    data validation tool
    environment variable validation

how to import Js module in TS
    import * as Name from "package";


entity
    DB에 저장되는 데이터의 형태를 보여주는 모델
    class that maps to a DB table
    
@ObjectType
    자동으로 스키마를 빌드하기 위해 사용하는 GraphQL decorator

@Entity
    TypeORM이 DB에 저장하게 해줄 것
    entity를 만든다음에, 어디에 있는지 TypeOrmModule에 알려줘야 저장

can combine @ObjectType and @Entity

Active Record vs Data Mapper : Data access patterns to DB
    Active Record
        extend BaseEntity
            user=new User();
            user.name="a"
            await user.save();
            User.find()

    Data Mapper
        use Repository
        Repository : Entity와 상호작용 하는걸 담당
        const userRepository = connection.getRepository(User);

        const user = new User();
        user.name="a"
        await userRepository.save(user);

        userRepository.find();
        
Data Mapper : 유지관리 하는걸 도와주고, 대규모 앱에서 유용
Active Record : 소규모 앱에서 단순하게 사용

NestJs : Repository를 사용하는 built-in modules 많음,

1. import repository
    imports:[TypeOrmModule.forFeature([Restaurant])]
2. inject repository to service
    constructor(
    @InjectRepository(Restaurant)
    private readonly restaurants: Repository<Restaurant>,
  ) {} 


create vs save
    1.save : save in the DB  
    2.create : not touch the DB, just create class
        can use short code
    
async function 사용하려면, return type은 Promise<value>

@ObjectType, @Field로 graphql type을 만듦
    자동으로 graphql과 연동되어서 수정할 필요가 없음
@Entity, @Column로 DB 스키마도 만들고 있음
    entity를 변경하면 dto도 매번 같이 변경해야 됨
    어떻게 통합?
        use Mapped Types

Mapped Types
    Classes that allows us to generate a type from another type with transformations
    base type을 바탕으로 다른 버전들을 만들 수 있게 해줌
    
    Partial Type
        모든 필드가 required가 아닌 클래스를 만들어줌

    Pick Type
        몇가지 property를 선택해서 새로운 클래스를 만들어줌

    Omit Type    
        몇몇 필드를 제외하고 만듦

    Partial Type + Pick Type으로 몇가지만 + optional 조합 가능

    Intersection Type
        combine types
    
    모두 Inputtype을 만들어냄
    base class는 input type
    Mapped Types의 결과는 @InputType,
    ObjectType인 객체를 넣었으면, option에 decorator를 변경할 수 있음
    딱히 쓰지 않는다면, parent class와 동일한 type을 return
    parent와 child type이 다르다면, decorator 옵션을 넣어 줘야 함
    entity에 @InputType을 만들어서도 처리 가능


    //for the graphql
    @Field((type) => Boolean, { defaultValue: true })
    //for the DB
    @Column({ default: true })
    //for the dto validation, can send or not
    @IsOptional()
    @IsBoolean()
    isVegan?: boolean;


TypeORM
    createDateColumn() : 생성될 때 자동으로 엔티티에 추가

typescript
    enum A{

    }
    registerEnumType(UserRole, { name: 'UserRole' });
        GraphQL type 추가(enum)

Entity Listener
    특정 entity event를 listen하는 custom logic이 있는 method를 가질 수 있음
    AfterLoad, BeforeUpdate, BeforeInsert등 여러가지 event있음
    
    after create, make entity
    before save(=before insert), hash
    
Cannot find module
    절대경로인지 확인해보기, dist 한번 지우고 다시 실행

jwt
    1. using nest/jwt, passport-jwt
    2. using jsonwebtoken
    token
        누구나 볼 수 있음, private 정보를 담지 말자
        토큰 값이 수정되었다면 not validation 알 수 있음
        수정되면 더 이상 유효하지 않음
        시크릿 토큰 키를 가진 사람만이 토큰을 만들 수 있음
        내부에 담겨진 정보가 아닌 정보의 진위 여부가 중요한 것
    
ConfigService를 import하면, ConfigModule의 필요한 것들을 사용할 수 있음

Dependency Injection
    원하는 class만 적어주면, nestjs가 우리를 위해서 그 정보를 가져다 줌
    app.module등 module에서 import하면, 그 module이 어딘가에 존재, 아직 정보가 살아있음
    ConfigModule을 import한 것 만으로, ConfigService를 가질 수 있음
    ConfigService를 imports 하는 것만으로 원하는걸 불러올 수 있음
    
Module은 2가지 종류가 있음
    static module
        어떤 설정도 되어있지 않음
    dynamic module(.forRoot)
        설정이 적용되어 있는 모듈
        become a static module
            동적인 모듈에 여러가지 옵션을 적용시켜준 후
            리턴 값으로 설정한 옵션들이 존재하는 상태의 정적인 모듈을 내보내는 것
            동적 모듈은 그저 중간 과정일 뿐
        isGlobal:true
            글로벌로 설정돼있어서, import할 필요 없음
            ConfigService도
        

Module
    providers
        instantiated by Nest injector
        shared at least across the module
        원하는 class/value를 provide할 수 있게 해줌
        Injection 하고 싶은 건 모두 providers에 넣고 nestjs에 요청하면 됨

    
    controllers
        url
    
    imports
        list of imported modules that export the providers which are required in this module
    
    exports
        the subset of providers that are provided by this module
        should be available in other modules which import this module
        imports가 아니라 import임

    JwtModule에서 A를 exports하고,
    JwtModule을 AppModule에서 import를 하면,
    A를 AppModule의 전체에서 다 쓸 수 있는 것

    단순히, 인터페이스만 어떤건지, type만 지정해주면 쓸 수 있음
    클래스 타입만 보고 imports 정의 에서 찾아줌
    imports정의에 없으면, 못 씀

    providers:[JwtService]
    = [{provide:JwtService, useClass:JwtService}]
    이거 말고도, useClass대신 useValue를 사용해서 value를 보내는 등
    여러 값을 보낼 수 있음

Middleware in nestJS
    implements : class가 interface처럼 동작
    
    express에서 구현하는 것과 같음 
    
    middleware 정의
    export class JwtMiddleware implements NestMiddleware{
        use(req:Request,res:Response, next:NextFunction){
            console.log(req.headers);
            next();
        }
    }

    middleware 등록

    1. in App Module
    export class AppModule implements NestModule {
        configure(consumer: MiddlewareConsumer) {
            consumer
            .apply(JwtMiddleware)
            .forRoutes({ path: '/graphql', method: RequestMethod.POST });
        }
    }

    2.main.ts
    app.use(jwtMiddleware);
    전체 어플리케이션에서 사용
    클래스는 사용 불가, 함수형태로 넣어야 함

    어떤 route에 middleware를 적용할지 결정
    route결정 방법은 forRoutes, excludes등 있음


graphql로 request 공유
    req를 graphql resolver에 전달
    graphql module이 apollo server에서 모든걸 가져와 사용할 수 있음

    A request context is available for each request(called function for each request)
    when context is defined as a function, it will be called on each request and will receive an
    object containing a req property, which represents the request itself.
    
    can use context in all the resolvers

    configure in the GraphQLModule.forRoot()

resolver can access context using @Context()
    
authorization guard
    request를 다음단계로 진행할지 말지 결정
    guard가 필요한 resolver에서, @UseGuards(guard)
    if true, request 진행.
    if false, request 중단

    using CanActivate, access to context
    context = http
    gqlContext로 바꿔줘야함

Custom Decorator
    use CreateParamDecorator

repository.update()
    does not check if entity exist in the DB
    그저 db에 쿼를 보낼 뿐
    BeforeUpdate() trigger 못함
    BeforeUpdate는 특정 entity를 update해야 trigger
    use save() method

    save()
        saves all given entities in the db.
        entity없으면 create, 있으면 update